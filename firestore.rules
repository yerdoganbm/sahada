rules_version = '2';

/**
 * Firestore Rules — Production guardrail baseline
 *
 * IMPORTANT:
 * - This baseline assumes Firebase Authentication (`request.auth.uid`) is in use.
 * - Current mobile app code in this repo still operates with permissive rules under `mobile/firestore.rules`.
 * - Privileged mutations must be performed by Cloud Functions (Admin SDK bypasses rules).
 */
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function uid() {
      return request.auth.uid;
    }

    function membershipId(teamId, userId) {
      return teamId + "_" + userId;
    }

    function membershipDoc(teamId, userId) {
      return get(/databases/$(database)/documents/memberships/$(membershipId(teamId, userId)));
    }

    function isActiveMember(teamId) {
      return isSignedIn()
        && membershipDoc(teamId, uid()).exists()
        && membershipDoc(teamId, uid()).data.status == "ACTIVE";
    }

    function isTeamAdmin(teamId) {
      return isActiveMember(teamId)
        && (
          membershipDoc(teamId, uid()).data.roleId == "TEAM_OWNER"
          || membershipDoc(teamId, uid()).data.roleId == "TEAM_ADMIN"
        );
    }

    function matchDoc(matchId) {
      return get(/databases/$(database)/documents/matches/$(matchId));
    }

    function matchTeamId(matchId) {
      return matchDoc(matchId).data.teamId;
    }

    function isActiveMemberForMatch(matchId) {
      return isSignedIn()
        && matchDoc(matchId).exists()
        && (matchTeamId(matchId) is string)
        && isActiveMember(matchTeamId(matchId));
    }

    function isPaymentOwner() {
      return isSignedIn() && resource.data.playerId == uid();
    }

    function onlyUpdatesPaymentProof() {
      // Allow only proof URL updates by the payment owner.
      return request.resource.data.diff(resource.data).affectedKeys()
        .hasOnly(["proofUrl", "proofUpdatedAt", "updatedAt", "updatedBy"]);
    }

    function venueDoc(venueId) {
      return get(/databases/$(database)/documents/venues/$(venueId));
    }

    function isVenueOwner(venueId) {
      return isSignedIn()
        && venueDoc(venueId).exists()
        && venueDoc(venueId).data.ownerId == uid();
    }

    function onlyUpdatesNotificationRead() {
      return request.resource.data.diff(resource.data).affectedKeys()
        .hasOnly(["isRead", "read", "readAt"]);
    }

    function onlyUpdatesReservationStatus() {
      return request.resource.data.diff(resource.data).affectedKeys()
        .hasOnly(["status", "updatedAt", "updatedBy"]);
    }

    // ─────────────────────────────────────────────
    // Users (self access only)
    // ─────────────────────────────────────────────
    match /users/{userId} {
      // Allow reading own profile, and allow reading other users in the same team tenant
      // (legacy compatibility: users.teamId is kept in sync with activeTeamId).
      allow read: if isSignedIn()
        && (
          uid() == userId
          || ((resource.data.teamId is string) && isActiveMember(resource.data.teamId))
        );
      allow create: if isSignedIn() && uid() == userId;
      allow update: if isSignedIn() && uid() == userId;
      allow delete: if false;
    }

    // ─────────────────────────────────────────────
    // Teams (read requires ACTIVE membership)
    // ─────────────────────────────────────────────
    match /teams/{teamId} {
      allow read: if isActiveMember(teamId);
      // Team creation / mutation must be done via Cloud Functions
      allow create, update, delete: if false;
    }

    // ─────────────────────────────────────────────
    // Matches (P2: capacity + waitlist model)
    // ─────────────────────────────────────────────
    match /matches/{matchId} {
      // Read match only for ACTIVE members of its team tenant.
      allow read: if isSignedIn() && (resource.data.teamId is string) && isActiveMember(resource.data.teamId);

      // All match writes should be privileged (Cloud Functions), including RSVP.
      allow create, update, delete: if false;

      // Participants subcollection (read-only for ACTIVE members; writes via functions)
      match /participants/{userId} {
        allow read: if isActiveMemberForMatch(matchId);
        allow create, update, delete: if false;
      }

      // Waitlist subcollection (read-only for ACTIVE members; writes via functions)
      match /waitlist/{userId} {
        allow read: if isActiveMemberForMatch(matchId);
        allow create, update, delete: if false;
      }
    }

    // ─────────────────────────────────────────────
    // Memberships (canonical)
    // ─────────────────────────────────────────────
    match /memberships/{membershipId} {
      // Allow reading own membership doc (self) or team admin (moderation UIs).
      allow read: if isSignedIn()
        && (
          resource.data.userId == uid()
          || isTeamAdmin(resource.data.teamId)
          || isActiveMember(resource.data.teamId)
        );

      // All membership status/role mutations must be via Cloud Functions.
      allow create, update, delete: if false;
    }

    // ─────────────────────────────────────────────
    // Join requests
    // ─────────────────────────────────────────────
    match /join_requests/{requestId} {
      allow read: if isSignedIn()
        && (
          resource.data.userId == uid()
          || isTeamAdmin(resource.data.teamId)
        );

      // A user can submit their own join request (APPROVAL policy) in a constrained shape.
      allow create: if isSignedIn()
        && request.resource.data.userId == uid()
        && request.resource.data.teamId is string
        && request.resource.data.status == "REQUESTED"
        // deterministic docId: "{teamId}_{userId}"
        && requestId == request.resource.data.teamId + "_" + request.resource.data.userId;

      // Approve/reject/cancel are privileged (functions only).
      allow update, delete: if false;
    }

    // ─────────────────────────────────────────────
    // Player proposals (legacy UI flow)
    // ─────────────────────────────────────────────
    match /player_join_requests/{requestId} {
      allow create: if isSignedIn()
        && request.resource.data.teamId is string
        && isActiveMember(request.resource.data.teamId)
        && request.resource.data.status == "pending";

      // Only team admins can review proposals (contains PII like phone).
      allow read: if isSignedIn()
        && (resource.data.teamId is string)
        && isTeamAdmin(resource.data.teamId);

      // Approve/reject are privileged (functions/UI admin only).
      allow update: if isSignedIn()
        && (resource.data.teamId is string)
        && isTeamAdmin(resource.data.teamId);

      allow delete: if false;
    }

    // ─────────────────────────────────────────────
    // Invites (tokenHash only; no plaintext token)
    // ─────────────────────────────────────────────
    match /invites/{inviteId} {
      // Accept / create / manage via Cloud Functions only.
      allow read, write: if false;
    }

    // ─────────────────────────────────────────────
    // Venues (catalog; owner can edit)
    // ─────────────────────────────────────────────
    match /venues/{venueId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.resource.data.name is string
        && request.resource.data.location is string
        && request.resource.data.ownerId == uid();
      allow update: if isSignedIn()
        && resource.data.ownerId == uid()
        && request.resource.data.ownerId == resource.data.ownerId;
      allow delete: if false;
    }

    // ─────────────────────────────────────────────
    // Reservations (createdBy or venue owner can read; venue owner can confirm)
    // ─────────────────────────────────────────────
    match /reservations/{reservationId} {
      allow create: if isSignedIn()
        && request.resource.data.venueId is string
        && request.resource.data.status == "pending"
        && request.resource.data.createdBy == uid();

      allow read: if isSignedIn()
        && (
          resource.data.createdBy == uid()
          || ((resource.data.venueId is string) && isVenueOwner(resource.data.venueId))
        );

      // Venue owner can update status (confirm/cancel/etc). Creator can only cancel.
      allow update: if isSignedIn()
        && (
          (
            (resource.data.venueId is string)
            && isVenueOwner(resource.data.venueId)
            && onlyUpdatesReservationStatus()
          )
          || (
            resource.data.createdBy == uid()
            && onlyUpdatesReservationStatus()
            && request.resource.data.status == "cancelled"
          )
        );

      allow delete: if false;
    }

    // ─────────────────────────────────────────────
    // Notifications (per-user or per-team)
    // ─────────────────────────────────────────────
    match /notifications/{notificationId} {
      allow read: if isSignedIn()
        && (
          (resource.data.userId == uid())
          || ((resource.data.teamId is string) && isActiveMember(resource.data.teamId))
        );
      allow update: if isSignedIn()
        && resource.data.userId == uid()
        && onlyUpdatesNotificationRead();
      allow create, delete: if false;
    }

    // ─────────────────────────────────────────────
    // Transactions (team scoped)
    // ─────────────────────────────────────────────
    match /transactions/{transactionId} {
      allow read: if isSignedIn()
        && (resource.data.teamId is string)
        && isActiveMember(resource.data.teamId);
      allow create: if isSignedIn()
        && request.resource.data.teamId is string
        && isTeamAdmin(request.resource.data.teamId)
        && request.resource.data.type in ["income", "expense"]
        && request.resource.data.amount is number
        && request.resource.data.date is string;
      allow update, delete: if false;
    }

    // ─────────────────────────────────────────────
    // Polls (team scoped; best-effort voting update)
    // ─────────────────────────────────────────────
    match /polls/{pollId} {
      allow read: if isSignedIn()
        && (resource.data.teamId is string)
        && isActiveMember(resource.data.teamId);

      allow create: if false;

      allow update: if isSignedIn()
        && (resource.data.teamId is string)
        && isActiveMember(resource.data.teamId)
        && request.resource.data.teamId == resource.data.teamId
        && request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(["options", "voters", "totalVotes"])
        && (resource.data.voters is list)
        && (request.resource.data.voters is list)
        && !resource.data.voters.hasAny([uid()])
        && request.resource.data.voters.hasAny([uid()]);

      allow delete: if false;
    }

    // ─────────────────────────────────────────────
    // Talent pool (team scoped; read-only for members)
    // ─────────────────────────────────────────────
    match /talent_pool/{talentId} {
      allow read: if isSignedIn()
        && (resource.data.teamId is string)
        && isActiveMember(resource.data.teamId);
      allow write: if false;
    }

    // ─────────────────────────────────────────────
    // Scout reports (global; read-only)
    // ─────────────────────────────────────────────
    match /scout_reports/{reportId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    // ─────────────────────────────────────────────
    // Tournament (public read-only)
    // ─────────────────────────────────────────────
    match /tournament_teams/{teamId} {
      allow read: if isSignedIn();
      allow write: if false;
    }
    match /bracket_matches/{matchId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    // ─────────────────────────────────────────────
    // Subscription plans (public read-only)
    // ─────────────────────────────────────────────
    match /subscription_plans/{planId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    // ─────────────────────────────────────────────
    // Payments (read for active members; limited proof updates by owner)
    // ─────────────────────────────────────────────
    match /payments/{paymentId} {
      allow read: if isSignedIn()
        && (resource.data.teamId is string)
        && isActiveMember(resource.data.teamId);

      // Allow only the payment owner to attach proofUrl (everything else via functions).
      allow update: if isPaymentOwner()
        && resource.data.status == "PENDING"
        && onlyUpdatesPaymentProof();

      allow create, delete: if false;
    }

    // Idempotency docs and rate limit buckets must never be client-written/read.
    match /payment_idempotency/{id} {
      allow read, write: if false;
    }
    match /rate_limits/{id} {
      allow read, write: if false;
    }

    // ─────────────────────────────────────────────
    // Audits (append-only, functions only)
    // ─────────────────────────────────────────────
    match /audits/{auditId} {
      allow read, write: if false;
    }

    // Default deny for any other collections until explicitly modeled.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

